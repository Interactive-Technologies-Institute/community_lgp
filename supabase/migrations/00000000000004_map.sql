/* MAP */
create table public.map_pins (
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
	lng double precision not null,
	lat double precision not null,
	user_id uuid references public.profiles not null,
	unique(user_id)
);
create trigger handle_updated_at before
update on public.map_pins for each row execute procedure moddatetime (updated_at);
create table public.map_pins_moderation(
	id bigint generated by default as identity primary key,
	inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
	map_pin_id bigint references public.map_pins not null,
	user_id uuid references public.profiles not null,
	status public.moderation_status not null,
	comment text not null
);
create function public.handle_map_pin_moderation_updates() returns trigger language plpgsql security definer as $$ begin
insert into public.map_pins_moderation (map_pin_id, user_id, status, comment)
values (
		new.id,
		new.user_id,
		'pending'::moderation_status,
		'Pending moderation'
	);
return new;
end;
$$;
create trigger on_map_pins_insert
after
insert on public.map_pins for each row execute procedure public.handle_map_pin_moderation_updates();
create trigger on_map_pins_update
after
update on public.map_pins for each row execute procedure public.handle_map_pin_moderation_updates();
create view public.latest_map_pins_moderation with (security_invoker = on) as
select distinct on (map_pin_id) *
from public.map_pins_moderation
order by map_pin_id,
	inserted_at desc;
create view public.map_pins_view with (security_invoker = on) as
select mp.*,
	m.status as moderation_status
from public.map_pins mp
	join public.latest_map_pins_moderation m on mp.id = m.map_pin_id;
-- RLS policies
alter table public.map_pins enable row level security;
alter table public.map_pins_moderation enable row level security;
create policy "Allow users to read approved map pins" on public.map_pins for
select using (
		exists (
			select 1
			from public.map_pins_moderation
			where map_pin_id = map_pins.id
				and status = 'approved'::moderation_status
		)
	);
create policy "Allow users to read their own map pins" on public.map_pins for
select using (auth.uid() = user_id);
create policy "Allow users to create their own map pins" on public.map_pins for
insert with check (
		(
			select authorize('map.create')
		)
		and auth.uid() = user_id
	);
create policy "Allow users to update their own map pins" on public.map_pins for
update using (
		(
			select authorize('map.update')
		)
		and auth.uid() = user_id
	) with check (auth.uid() = user_id);
create policy "Allow users to delete their own map pins" on public.map_pins for delete using (
	(
		select authorize('map.delete')
	)
	and auth.uid() = user_id
);
create policy "Allow moderators read all map pins" on public.map_pins for
select using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators update all map pins" on public.map_pins for
update using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators delete all map pins" on public.map_pins for delete using (
	(
		select authorize('map.moderate')
	)
);
create policy "Allow users to read approved map pins moderation" on public.map_pins_moderation for
select using (
		status = 'approved'::public.moderation_status
	);
create policy "Allow users to read their own map pins moderation" on public.map_pins_moderation for
select using (auth.uid() = user_id);
create policy "Allow moderators to read all map pins moderation" on public.map_pins_moderation for
select using (
		(
			select authorize('map.moderate')
		)
	);
create policy "Allow moderators to insert all map pins moderation" on public.map_pins_moderation for
insert with check (
		(
			select authorize('map.moderate')
		)
	);