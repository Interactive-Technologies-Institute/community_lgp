-- Create Signs Table
create table public.signs (
    id bigint generated by default as identity primary key,
    annotated boolean not null,
    annotation jsonb not null,
    annotation_array integer[] not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    is_annotated integer not null,
    last_changed timestamp with time zone default timezone('utc'::text, now()) not null,
    name varchar(255) not null,
    selected boolean not null,
    theme text[] not null,
    video text not null,
    written_annotation text[], 
    user_id uuid references public.profiles not null
);

alter table public.signs drop column if exists fts;
alter table public.signs add column fts tsvector;

update public.signs
set fts = to_tsvector('simple', coalesce(name, '') || ' ' || coalesce((
    select string_agg(value::text, ' ')
    from jsonb_array_elements_text(annotation) as value
), ''));

create or replace function update_signs_fts() returns trigger as $$
begin
    new.fts := to_tsvector('simple', coalesce(new.name, '') || ' ' || coalesce((
        case
            when jsonb_typeof(new.annotation) = 'array' then (
                select string_agg(value::text, ' ')
                from jsonb_array_elements_text(new.annotation) as value
            )
            when jsonb_typeof(new.annotation) = 'object' then (
                select string_agg(value::text, ' ')
                from jsonb_each_text(new.annotation) as value
            )
            else ''
        end
    ), ''));
    return new;
end;
$$ language plpgsql;

create trigger signs_fts_trigger
before insert or update on public.signs
for each row
execute procedure update_signs_fts();

-- Create the index
create index signs_fts on public.signs using gin (fts);

-- Trigger to handle last_changed update
create trigger handle_last_changed before
update on public.signs for each row execute procedure moddatetime (last_changed);

-- Create Signs Interested Table
create table public.signs_interested(
    id bigint generated by default as identity primary key,
    inserted_at timestamp with time zone default timezone('utc'::text, now()) not null,
    user_id uuid references public.profiles not null,
    sign_id bigint references public.signs not null,
    unique (user_id, sign_id)
);

-- Function to get sign interest count and check if user is interested
create function public.get_sign_interest_count(sign_id bigint, user_id uuid default null) returns table (count bigint, has_interest boolean) language sql security definer as $$
select count(*) as interest_count,
    case
        when exists (
            select 1
            from public.signs_interested
            where user_id = user_id
                and sign_id = sign_id
        ) then true
        else false
    end as has_interest
from public.signs_interested
where sign_id = sign_id;
$$;

-- Create Views for Signs
create view public.signs_view with (security_invoker = on) as
select s.*
from public.signs s;

create view public.signs_tags with (security_invoker = on) as
select unnest(theme) as tag,
    count(*) as count
from public.signs
group by tag;

-- Enable Row Level Security (RLS)
alter table public.signs enable row level security;

-- RLS Policies for Signs
create policy "Allow users to read their own signs" on public.signs for
select using (auth.uid() = user_id);

create policy "Allow users to create their own signs" on public.signs for
insert with check (
    auth.uid() = user_id
);

create policy "Allow users to update their own signs" on public.signs for
update using (
    auth.uid() = user_id
);

create policy "Allow users to delete their own signs" on public.signs for delete using (
    auth.uid() = user_id
);



-- Storage Bucket for Signs
insert into storage.buckets (id, name, public, allowed_mime_types)
values ('signs', 'Signs', true, '{"image/*", "video/*"}');

-- RLS Policies for the storage bucket
create policy "Allow users to upload images and videos for their signs" on storage.objects for
insert to authenticated with check (bucket_id = 'signs');
